# JCrypTool third party libraries target platform components

This project serves the [JCrypTool (JCT) project](https://github.com/jcryptool/core). JCT is an Eclipse Rich Client Platform application. It requires Java artifacts (JARs) to be provided as OSGi bundles. Often, these can be found on the [Eclipse Orbit](https://www.eclipse.org/orbit/) update sites. However, some times this is not enough. Examples for which this project was initially conceived are:

- Migration from Java 8 to Java 11: We missed javax.xml functionality which was removed from the JDK between those versions. The Orbit bundles were outdated (javax.xml 2.2), however, we required an API from 2.3 upward.
- Bugfixes of Eclipse platform libraries (as incubation before they ideally end up upstream and we don't need them anymore)

To that end, two solutions are possible: 

1) package those JARs by hand as bundles and keep those manually-generated artifacts in our core repository
2) depend on Maven to do this job for us.

Now, 1) is a manual and laborious process for each new artifact or update thereof and prone to errors. 2) seems sensible for artifacts that are already in the maven central repositories. After all, Maven is designed to provide for third party dependencies, why should this be a problem for a Java-based application like JCT? In other words, why don't we stick our third-party dependencies into a ``pom.xml``?

For multiple, frustrating reasons, best explained [here](https://web.archive.org/web/20181018213714/http://www.bernd-adamowicz.de:80/105/automated-build-of-rcp-artifacts-with-maven-tycho-a-field-report-part-1/) in an analysis of five approaches and [here](https://github.com/reficio/p2-maven-plugin). In a nutshell, we need Maven Tycho to build our product, pom.xml based, but all "built-in solutions" to depend on Maven artifacts in an eclipse product built with Tycho behave like they are merely tacked on hastily to enable purely local workflows somehow, but break down when you need to automatically build and deploy such a project.

Of course, there are solutions, and this project represents what I think is the best, most sane and principled way to go about it. It is based on the considerations brought up by the previously linked articles.

## Basic structure of how it works

By example of packaged ``javax.xml`` xml bindings and providers:

TODO: explain project structure

# Used software


- [**Apache Felix Maven plugin**](https://felix.apache.org/) - packages a Maven project *including its dependencies* as a bundle and additionally [shades](https://maven.apache.org/plugins/maven-shade-plugin/) the packaged dependencies.
- [**p2-maven-plugin**](https://github.com/reficio/p2-maven-plugin) - resolves Maven artifacts (as generated by the Felix plugin) and packages them as an Eclipse P2 update site
- [**Eclipse Jetty Maven plugin**](https://www.eclipse.org/jetty/) - Hosts the p2 update site locally (e.g. https://localhost:8080/site)

# Related Tutorials


- [Tutorial on Eclipse OSGi mechanisms and Tycho](https://www.vogella.com/tutorials/EclipseTycho/article.html)
- [The excellent writeup in the p2-maven-plugin README]()
- [Tutorial on deploying with p2-maven-plugin, including a few advanced Maven configuration tricks](https://www.vogella.com/tutorials/EclipseJarToPlugin/article.html#convert-jar-files-to-osgi-bundles-with-the-p2-maven-plugin)
